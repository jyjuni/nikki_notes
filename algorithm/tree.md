# 二叉树

[二叉树 - 左程云算法基础班](https://www.bilibili.com/video/BV1kQ4y1h7ok?p=6&vd_source=3ee85a74f53c722d5c1f8a852c0c7504) 

## 原理

### 先序、中序和后序遍历

递归行为中，每一个节点三次到达自己：

```python
def f(root):
  if not root:
    return 
  # 1
  f(root.left)
  # 2
  f(root.right)
  # 3
```

第一次到达自己时打印 -- 先序

第二次到达自己时打印 -- 中序

第三次到达自己时打印 -- 后序

#### 实现

1. 递归
2. 非递归（手动压栈）

先序

中序：左头右

- 每棵子树整棵树左边界（一路顺着left走到底）进栈，依次弹的过程中打印，如果弹出节点有右树，对右树周而复始（左边界进栈...）

- 原理：把整棵树分解为子树的左边界

  左头右

  ​		左头右

  ​				左头右

后序：头右左，弹出的压入收集栈

### 宽度优先遍历

##### 二叉树最大宽度

 [662. 二叉树最大宽度 - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-width-of-binary-tree/) 

### 搜索二叉树

`左树<root`且`右树>root`

**如何判断是搜索二叉树？**

方法一：中序遍历的结果是升序的

方法二：递归

- 返回：`min`, `max`, `isBST`
- 判断 `left.isBST && right.isBST && left.max<root<right.min` 

### 完全二叉树

完全二叉树：除了最后一层都是满的，最后一层从左到右

**如何判断是完全二叉树？**

按层遍历（bfs），判断两个非法条件：

- 任一节点有右孩子无左孩子，返回false

- 如果遇到了第一个**左右孩子不双全**的情况，后续节点都必须是叶节点（无孩子），否则返回false

### 满二叉树

**如何判断是满二叉树？**

查找：

- 最大深度L

- 节点个数N

如果一棵树是满二叉树：$N = 2^L -1$

### 平衡二叉树

平衡二叉树：对于任何一棵子树，左树深度和右树深度差不超过$1$

如何判断是平衡二叉树？

- 左树是平衡二叉树
- 右树是平衡二叉树
- $\vert 左高度-右高度\vert \leq 1$ 

### 二叉树的序列化和反序列化

以什么样的方式序列化，就以什么方式反序列化

序列化：空则`_#`，其他`_val`

反序列化（重建子树）：递归

## 例题

##### 两个节点的最低公共祖先(LCA)

解法一：

**维护辅助哈希表**father，递归存储每个节点的父节点。

从o1往上追溯父节点链并记录下来，然后从o2开始往上追溯，遇到有存在o1父节点链里的就返回。

解法二：递归（不用辅助表）

<img src="tree.assets/Screen Shot 2022-10-15 at 12.33.45 AM.png" alt="Screen Shot 2022-10-15 at 12.33.45 AM" style="zoom:50%;" />

##### 后继节点和前驱结点

后继节点：中序遍历后一个节点

前驱结点：中序遍历前一个节点

如果每个节点有父节点指针，如何能够快速的找到后继节点？（时间复杂度$O(K)$,$K$为后继节点距离）

1. x 有右树：右树上的最左节点
2. x无右树：往上走，直到**当前节点是父亲的左孩子**（因为在找到这个节点前一直都是右孩子，所以一定是左子树上最后一个打印的，则下一个就是父节点），或者**父亲是空**（node一路都是右节点，则它就是最后一个节点，它的后继节点为null）

##### 折纸问题

> 请把纸条竖着放在桌⼦上，然后从纸条的下边向上⽅对折，压出折痕后再展 开。此时有1条折痕，突起的⽅向指向纸条的背⾯，这条折痕叫做“下”折痕 ；突起的⽅向指向纸条正⾯的折痕叫做“上”折痕。如果每次都从下边向上⽅ 对折，对折N次。请从上到下计算出所有折痕的⽅向。
>
> 给定折的次数**n**,请返回从上到下的折痕的数组，若为下折痕则对应元素为"down",若为上折痕则为"up".

解法：中序遍历，根节点为凹，左孩子为凹，右孩子为凸。



##### 其他练习

3.6树
101 102 103 104 105 106 112 116 117
